package net.stemmaweb.exporter;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.output.StringBuilderWriter;
import org.neo4j.graphdb.Direction;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.graphdb.Transaction;

import com.sun.xml.txw2.output.IndentingXMLStreamWriter;

import net.stemmaweb.model.ReadingModel;
import net.stemmaweb.model.UserModel;
import net.stemmaweb.model.VariantListModel;
import net.stemmaweb.model.VariantLocationModel;
import net.stemmaweb.model.VariantModel;
import net.stemmaweb.model.WitnessModel;
import net.stemmaweb.rest.ERelations;
import net.stemmaweb.services.GraphDatabaseServiceProvider;
import net.stemmaweb.services.ReadingsDbService;
import net.stemmaweb.services.VariantGraphService;
import net.stemmaweb.services.WitnessDbService;

public class TEIExporter {
	private final GraphDatabaseService db = (new GraphDatabaseServiceProvider()).getDatabase();

	private ReadingsDbService readingsService = new ReadingsDbService();
	private WitnessDbService witnessService = new WitnessDbService();

	private void writeTEIHeader(XMLStreamWriter writer, Map<String, String> extraParams) throws XMLStreamException {
		// Get the information that is in the tradition node
		writer.writeStartElement("teiHeader");
		writer.writeStartElement("fileDesc");
		writer.writeStartElement("titleStmt");
		writer.writeStartElement("title");
		writer.writeCharacters(extraParams.getOrDefault("title", "TITLE NOT SET"));
		writer.writeEndElement(); // title
		String[] titleDescElements = { "author", "editor", "sponsor", "funder", "principal" };
		// Handle the easy keywords
		for (String kw : titleDescElements) {
			if (extraParams.containsKey(kw)) {
				writer.writeStartElement(kw);
				writer.writeCharacters(extraParams.get(kw));
				writer.writeEndElement();
			}
		}
		// Handle the resp keywords
		AtomicReference<String> errorMsg = new AtomicReference<>();
		errorMsg.set("");
		extraParams.keySet().stream().filter(x -> x.startsWith("tresp:")).forEach(x -> {
			String[] parts = x.split(":", 1);
			try {
				writer.writeStartElement("respStmt");
				writer.writeStartElement(parts[1]);
				writer.writeCharacters(extraParams.get(x));
				writer.writeEndElement();
			} catch (XMLStreamException e) {
				e.printStackTrace();
				errorMsg.set(e.getMessage());
			}
		});
		if (!errorMsg.toString().equals(""))
			throw new XMLStreamException(errorMsg.toString());
		writer.writeEndElement(); // titleStmt

		// Now do the publication statement
		writer.writeStartElement("publicationStmt");
		writer.writeStartElement("publisher");
		writer.writeCharacters("Generated by Stemmarest");
		writer.writeEndElement(); // publisher
		writer.writeStartElement("date");
		writer.writeCharacters(LocalDate.now().toString());
		writer.writeEndElement(); // date
		String[] pubDescElements = { "idno", "availability", "license" };
		for (String kw : pubDescElements) {
			if (extraParams.containsKey(kw)) {
				writer.writeStartElement(kw);
				writer.writeCharacters(extraParams.get(kw));
				writer.writeEndElement();
			}
		}
		errorMsg.set("");
		extraParams.keySet().stream().filter(x -> x.startsWith("presp:")).forEach(x -> {
			String[] parts = x.split(":", 1);
			try {
				writer.writeStartElement("respStmt");
				writer.writeStartElement(parts[1]);
				writer.writeCharacters(extraParams.get(x));
				writer.writeEndElement();
			} catch (XMLStreamException e) {
				e.printStackTrace();
				errorMsg.set(e.getMessage());
			}
		});
		writer.writeEndElement(); // publicationStmt

		// note double-end-point attachment format
		writer.writeStartElement("encodingDesc");
		writer.writeStartElement("variantEncoding");
		writer.writeAttribute("method", "double​-end​-point");
		writer.writeAttribute("location", "internal");
		writer.writeEndElement();
		writer.writeEndElement();

		// ...and the source description
		writer.writeStartElement("sourceDesc");
		writer.writeStartElement("listWit");
		for (String k : extraParams.keySet().stream().filter(x -> x.startsWith("witness:"))
				.collect(Collectors.toSet())) {
			String sig = extraParams.get(k);
			writer.writeStartElement("witness");
			writer.writeAttribute("xml:id", sig);
			writer.writeStartElement("msDesc");
			writer.writeStartElement("msIdentifier");
			if (extraParams.containsKey(sig + ":idno")) {
				// We are writing the three-part specification
				for (String tag : new String[] { "settlement", "repository", "idno" }) {
					writer.writeStartElement(tag);
					writer.writeCharacters(extraParams.getOrDefault(sig + ":" + tag, "UNSPECIFIED"));
					writer.writeEndElement(); // $tag
				}
			} else {
				// We are only writing an msName
				writer.writeStartElement("msName");
				writer.writeCharacters(extraParams.getOrDefault(sig + ":msName", "Manuscript " + sig));
				writer.writeEndElement(); // msName
			}
			writer.writeEndElement(); // msIdentifier
			writer.writeEndElement(); // msDesc
			writer.writeEndElement(); // witness
		}
		writer.writeEndElement(); // listWit
		writer.writeEndElement(); // sourceDesc
		writer.writeEndElement(); // fileDesc
		writer.writeEndElement(); // teiHeader
	}

	private String createXmlError(String msg) throws XMLStreamException {
		StringBuilder sb = new StringBuilder();
		XMLOutputFactory output = XMLOutputFactory.newInstance();
		XMLStreamWriter writer = new IndentingXMLStreamWriter(
				output.createXMLStreamWriter(new StringBuilderWriter(sb)));
		writer.writeStartDocument();
		writer.writeStartElement("error");
		writer.writeCharacters(msg);
		writer.writeEndElement();
		writer.flush();
		writer.close();
		return sb.toString();
	}

	/**
	 * Write a tradition, or a single section thereof, out to TEI double endpoint
	 * attachment format. If a lemma text is set, this will be the main text that
	 * the apparatus is based on; if not, the main text will be the majority text
	 * (defined arbitrarily in the case of equal readings.) The result will be a
	 * string that contains the XML output.
	 *
	 * @param tradId      - The tradition to export
	 * @param sectionId   - The section to export; 'null' means export the whole
	 *                    tradition.
	 * @param extraParams - A map of keywords and their values for the TEI header.
	 *                    Possibilities for the titleStmt section are author,
	 *                    editor, sponsor, funder, principal; responsibility
	 *                    statements may also be included in the titleStmt using the
	 *                    keywords "tresp:resp" and "tresp:name". Possibilities for
	 *                    the publicationStmt section are idno, availability,
	 *                    license; responsibility statements may also be included in
	 *                    the publication statement using the keywords "presp:resp"
	 *                    and "presp:name". For the sourceDesc the witnesses in the
	 *                    tradition will be listed by sigil; extra information can
	 *                    be specified for each witness by its sigil using keywords
	 *                    (substitute SIG for the actual sigil): (SIG:settlement,
	 *                    SIG:repository, SIG:idno) or SIG:msName.
	 *
	 * @return a Response containing an XML string that represents the requested
	 *         tradition/section
	 * @throws XMLStreamException
	 * @throws IOException
	 */
	public Response writeTEI(String tradId, String sectionId, Map<String, String> extraParams)
			throws XMLStreamException, IOException {
		Node traditionNode = VariantGraphService.getTraditionNode(tradId, db);
		if (traditionNode == null)
			return Response.status(Response.Status.NOT_FOUND).entity(createXmlError("No tradition found for this ID"))
					.build();
		Node traditionStartNode = VariantGraphService.getStartNode(tradId, db);
		if (traditionStartNode == null)
			return Response.status(Response.Status.NOT_FOUND)
					.entity(createXmlError("No graph found for this tradition.")).build();

		// If a specific section was requested, check that it exists
		if (sectionId != null && !sectionId.equals("")
				&& !VariantGraphService.sectionInTradition(tradId, sectionId, db))
			return Response.status(Response.Status.NOT_FOUND)
					.entity(createXmlError("Requested section not found in tradition")).build();

		// If we weren't passed in extra parameters for the TEI header, start collecting
		// them here
		if (extraParams == null) {
			extraParams = new HashMap<>();
		}

		// Everything in one big try block because so many things can raise exceptions
		File file;
		try (Transaction tx = db.beginTx()) {
			file = File.createTempFile("output", ".xml");
			file.deleteOnExit();
			OutputStream out = new FileOutputStream(file);

			XMLOutputFactory output = XMLOutputFactory.newInstance();
			XMLStreamWriter writer = new IndentingXMLStreamWriter(output.createXMLStreamWriter(out));
			writer.writeStartDocument();
			writer.writeStartElement("TEI");
			writer.writeAttribute("xmlns", "http://www.tei-c.org/ns/1.0");

			// Collect the parameters needed for the TEI header
			extraParams.put("title", traditionNode.getProperty("name").toString());
			if (traditionNode.hasRelationship(Direction.INCOMING, ERelations.OWNS_TRADITION)) {
				Node ownNode = traditionNode.getSingleRelationship(ERelations.OWNS_TRADITION, Direction.INCOMING)
						.getStartNode();
				extraParams.put("owner", (new UserModel(ownNode)).getId());
			}
			for (Relationship r : traditionNode.getRelationships(ERelations.HAS_WITNESS, Direction.OUTGOING)) {
				WitnessModel wm = new WitnessModel(r.getEndNode());
				extraParams.put("witness:" + wm.getId(), wm.getSigil());
			}
			writeTEIHeader(writer, extraParams);

			// Start chaining the text together
			writer.writeStartElement("text");
			ArrayList<Node> sectionList = new ArrayList<>();
			VariantListModel vlocs = null;
			Node sectionNode = null;
			if (sectionId != null) {
				sectionNode = db.getNodeById(Long.parseLong(sectionId));
				sectionList.add(sectionNode);
				vlocs = new VariantListModel(sectionNode, null, new ArrayList<String>(), null, "punct", false, false,
						"no", false);
				
			} else {
				// TODO: for traditions
				sectionList = VariantGraphService.getSectionNodes(tradId, db);
			}
			
			// TODO: pass base witness and follow
			List<Relationship> baseReadings = new ArrayList<Relationship>();
			VariantGraphService.getBaseText(sectionNode, sectionNode, null, ERelations.SEQUENCE, baseReadings);
			
			List<ReadingModel> baseChain = baseReadings.stream().map(x -> new ReadingModel(x.getEndNode())).collect(Collectors.toList());
            baseChain.add(0, new ReadingModel(baseReadings.get(0).getStartNode()));
            
			writer.writeStartElement("body");
			long idCounter = 1;
			if (vlocs != null) {
				Iterator<VariantLocationModel> iterator = vlocs.getVariantlist().iterator();
				VariantLocationModel variant  = null;
				if (iterator.hasNext()) {
					variant = iterator.next();
				}
				ReadingModel prev = null;
				for (ReadingModel baseReading : baseChain) {
					if (variant != null && variant.getVariants() != null && variant.getVariants().size() > 0) {
						boolean hasBeenWritten = false;
						while (variant != null) {
							if (prev != null && variant.getBefore().getId().equals(prev.getId())) {
								writer.writeEmptyElement("anchor");
								// create an id for the next lemma
								String id = "ID" + idCounter++;
								writer.writeAttribute("id", id);
								// if there is a base reading, we print it
								boolean hasBase = variant.getBase() != null && variant.getBase().size()>0;
								if (hasBase) {
									writer.writeCharacters(getText(baseReading));
									hasBeenWritten = true;
								}
								writeReadings(writer, variant, id);
								if (iterator.hasNext()) {
									variant = iterator.next();		
								} else {
									variant = null;
								}
							} else {
								if (!hasBeenWritten) {
									writer.writeCharacters(getText(baseReading));
								}
								break;
							}
						}
					} else {
						writer.writeCharacters(getText(baseReading));
					}
					prev = baseReading;
					
					
				}
				for (VariantLocationModel vlocModel : vlocs.getVariantlist()) {
					
					for (ReadingModel reading : vlocModel.getBase()) {
						writer.writeStartElement("variant");
						if (vlocModel.getVariants() != null && vlocModel.getVariants().stream()
								.anyMatch(v -> v.getReadings() != null && !v.getReadings().isEmpty())) { // !section.getVariants().isEmpty())
																											// {

							//writer.writeEmptyElement("anchor");
							
							// create an id for the next lemma
							String id = "ID" + idCounter++;
							writer.writeAttribute("id", id);
							writer.writeCharacters(getText(reading));
							writeReadings(writer, vlocModel, id);
						} else {
							writer.writeCharacters(getText(reading));
						}
						writer.writeEndElement();
					}
				}
			}
			writer.writeEndElement();

			writer.writeEndElement();
			writer.writeEndElement();
			// eventually...
			tx.success();
			writer.flush();
			out.close();
		} catch (IOException | XMLStreamException e) {
			String msg = "Error setting up XML output: " + e.getMessage();
			return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createXmlError(msg)).build();
		} catch (Exception e) {
			e.printStackTrace();
			String msg = "Error generating TEI output: " + e.getMessage();
			return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createXmlError(msg)).build();
		}

		return Response.ok(FileUtils.readFileToString(file, Charset.forName("UTF-8")), MediaType.APPLICATION_XML_TYPE)
				.build();
	}

	private String getText(ReadingModel reading) {
		if (reading.getJoin_next()) {
			return reading.getText();
		}
		return reading.getText() + " ";
	}

	private void writeReadings(XMLStreamWriter writer, VariantLocationModel section, String id)
			throws XMLStreamException {
		writer.writeStartElement("app");
		writer.writeAttribute("from", id);
		for (VariantModel variant : section.getVariants()) {
			if (variant.getReadings() != null && !variant.getReadings().isEmpty()) {
				for (ReadingModel variantReading : variant.getReadings()) {
					writer.writeStartElement("rdg");
					StringBuffer sigils = new StringBuffer();
					for (String sigil : variantReading.getWitnesses()) {
						sigils.append("#" + sigil + " ");
					}
					writer.writeAttribute("wit", sigils.toString().trim());
					writer.writeCharacters(variantReading.getText());
					writer.writeEndElement();
				}
			}
		}
		writer.writeEndElement();

	}
}
