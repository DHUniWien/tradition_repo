package net.stemmaweb.exporter;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import org.apache.commons.collections4.iterators.PeekingIterator;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.output.StringBuilderWriter;
import org.neo4j.graphdb.Direction;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.graphdb.Transaction;

import com.sun.xml.txw2.output.IndentingXMLStreamWriter;

import net.stemmaweb.model.ReadingModel;
import net.stemmaweb.model.SectionModel;
import net.stemmaweb.model.UserModel;
import net.stemmaweb.model.VariantListModel;
import net.stemmaweb.model.VariantLocationModel;
import net.stemmaweb.model.VariantModel;
import net.stemmaweb.model.WitnessModel;
import net.stemmaweb.rest.ERelations;
import net.stemmaweb.services.GraphDatabaseServiceProvider;
import net.stemmaweb.services.VariantGraphService;

public class TEIExporter {
	private final GraphDatabaseService db = (new GraphDatabaseServiceProvider()).getDatabase();

	private static String writeRespStatement(XMLStreamWriter writer, Map<String, String> extraParams, String tag) {
		AtomicReference<String> errorMsg = new AtomicReference<>();
		errorMsg.set("");
		extraParams.keySet().stream().filter(x -> x.startsWith(tag)).forEach(x -> {
			String[] parts = x.split(":", 1);
			try {
				writer.writeStartElement("respStmt");
				writer.writeStartElement(parts[1]);
				writer.writeCharacters(extraParams.get(x));
				writer.writeEndElement();
			} catch (XMLStreamException e) {
				e.printStackTrace();
				errorMsg.set(e.getMessage());
			}
		});
		return errorMsg.get();
	}
	private void writeTEIHeader(XMLStreamWriter writer, Map<String, String> extraParams) throws XMLStreamException {
		// Get the information that is in the tradition node
		writer.writeStartElement("teiHeader");
		writer.writeStartElement("fileDesc");
		writer.writeStartElement("titleStmt");
		writer.writeStartElement("title");
		writer.writeCharacters(extraParams.getOrDefault("title", "TITLE NOT SET"));
		writer.writeEndElement(); // title
		String[] titleDescElements = { "author", "editor", "sponsor", "funder", "principal" };
		// Handle the easy keywords
		for (String kw : titleDescElements) {
			if (extraParams.containsKey(kw)) {
				writer.writeStartElement(kw);
				writer.writeCharacters(extraParams.get(kw));
				writer.writeEndElement();
			}
		}
		// Handle the resp keywords
		String errorMsg = writeRespStatement(writer, extraParams, "tresp:");
		if (!errorMsg.equals(""))
			throw new XMLStreamException(errorMsg);
		writer.writeEndElement(); // titleStmt

		// Now do the publication statement
		writer.writeStartElement("publicationStmt");
		writer.writeStartElement("publisher");
		writer.writeCharacters("Generated by Stemmarest");
		writer.writeEndElement(); // publisher
		writer.writeStartElement("date");
		writer.writeCharacters(LocalDate.now().toString());
		writer.writeEndElement(); // date
		String[] pubDescElements = { "idno", "availability", "license" };
		for (String kw : pubDescElements) {
			if (extraParams.containsKey(kw)) {
				writer.writeStartElement(kw);
				writer.writeCharacters(extraParams.get(kw));
				writer.writeEndElement();
			}
		}
		errorMsg = writeRespStatement(writer, extraParams, "presp:");
		if (!errorMsg.equals(""))
			throw new XMLStreamException(errorMsg);
		writer.writeEndElement(); // publicationStmt

		// note double-end-point attachment format
		writer.writeStartElement("encodingDesc");
		writer.writeStartElement("variantEncoding");
		writer.writeAttribute("method", "double​-end​-point");
		writer.writeAttribute("location", "internal");
		writer.writeEndElement();
		writer.writeEndElement();

		// ...and the source description
		writer.writeStartElement("sourceDesc");
		writer.writeStartElement("listWit");
		for (String k : extraParams.keySet().stream().filter(x -> x.startsWith("witness:"))
				.collect(Collectors.toSet())) {
			String sig = extraParams.get(k);
			writer.writeStartElement("witness");
			writer.writeAttribute("xml:id", sig);
			writer.writeStartElement("msDesc");
			writer.writeStartElement("msIdentifier");
			if (extraParams.containsKey(sig + ":idno")) {
				// We are writing the three-part specification
				for (String tag : new String[] { "settlement", "repository", "idno" }) {
					writer.writeStartElement(tag);
					writer.writeCharacters(extraParams.getOrDefault(sig + ":" + tag, "UNSPECIFIED"));
					writer.writeEndElement(); // $tag
				}
			} else {
				// We are only writing an msName
				writer.writeStartElement("msName");
				writer.writeCharacters(extraParams.getOrDefault(sig + ":msName", "Manuscript " + sig));
				writer.writeEndElement(); // msName
			}
			writer.writeEndElement(); // msIdentifier
			writer.writeEndElement(); // msDesc
			writer.writeEndElement(); // witness
		}
		writer.writeEndElement(); // listWit
		writer.writeEndElement(); // sourceDesc
		writer.writeEndElement(); // fileDesc
		writer.writeEndElement(); // teiHeader
	}

	private String createXmlError(String msg) throws XMLStreamException {
		StringBuilder sb = new StringBuilder();
		XMLOutputFactory output = XMLOutputFactory.newInstance();
		XMLStreamWriter writer = new IndentingXMLStreamWriter(
				output.createXMLStreamWriter(new StringBuilderWriter(sb)));
		writer.writeStartDocument();
		writer.writeStartElement("error");
		writer.writeCharacters(msg);
		writer.writeEndElement();
		writer.flush();
		writer.close();
		return sb.toString();
	}

	/**
	 * Write a tradition, or a single section thereof, out to TEI double endpoint
	 * attachment format. If a lemma text is set, this will be the main text that
	 * the apparatus is based on; if not, the main text will be the majority text
	 * (defined arbitrarily in the case of equal readings.) The result will be a
	 * string that contains the XML output.
	 *
	 * @param tradId      - The tradition to export
	 * @param sectionId   - The section to export; 'null' means export the whole
	 *                    tradition.
	 * @param extraParams - A map of keywords and their values for the TEI header.
	 *                    Possibilities for the titleStmt section are author,
	 *                    editor, sponsor, funder, principal; responsibility
	 *                    statements may also be included in the titleStmt using the
	 *                    keywords "tresp:resp" and "tresp:name". Possibilities for
	 *                    the publicationStmt section are idno, availability,
	 *                    license; responsibility statements may also be included in
	 *                    the publication statement using the keywords "presp:resp"
	 *                    and "presp:name". For the sourceDesc the witnesses in the
	 *                    tradition will be listed by sigil; extra information can
	 *                    be specified for each witness by its sigil using keywords
	 *                    (substitute SIG for the actual sigil): (SIG:settlement,
	 *                    SIG:repository, SIG:idno) or SIG:msName.
	 * @param baseWitness - Witness to use as base.
	 * @param excludeWitnesses - Witness to be excluded.
	 *
	 * @return a Response containing an XML string that represents the requested
	 *         tradition/section
	 * @throws XMLStreamException passed through from XMLWriter
	 * @throws IOException passed through from FileUtils
	 */
	public Response writeTEI(String tradId, String sectionId, Map<String, String> extraParams, String baseWitness,
							 List<String> excludeWitnesses, String conflate, String suppress, Boolean filterNonsense,
							 Boolean filterTypeOne, String significant, Boolean combine)
			throws XMLStreamException, IOException {
		Node traditionNode = VariantGraphService.getTraditionNode(tradId, db);
		if (traditionNode == null)
			return Response.status(Response.Status.NOT_FOUND).entity(createXmlError("No tradition found for this ID"))
					.build();
		Node traditionStartNode = VariantGraphService.getStartNode(tradId, db);
		if (traditionStartNode == null)
			return Response.status(Response.Status.NOT_FOUND)
					.entity(createXmlError("No graph found for this tradition.")).build();

		// If a specific section was requested, check that it exists
		if (sectionId != null && !sectionId.equals("")
				&& !VariantGraphService.sectionInTradition(tradId, sectionId, db))
			return Response.status(Response.Status.NOT_FOUND)
					.entity(createXmlError("Requested section not found in tradition")).build();

		// If we weren't passed in extra parameters for the TEI header, start collecting
		// them here
		if (extraParams == null) {
			extraParams = new HashMap<>();
		}

		// Everything in one big try block because so many things can raise exceptions
		File file;
		try (Transaction tx = db.beginTx()) {
			file = File.createTempFile("output", ".xml");
			file.deleteOnExit();
			OutputStream out = new FileOutputStream(file);

			XMLOutputFactory output = XMLOutputFactory.newInstance();
			XMLStreamWriter writer = new IndentingXMLStreamWriter(output.createXMLStreamWriter(out));
			writer.writeStartDocument();
			writer.writeStartElement("TEI");
			writer.writeAttribute("xmlns", "http://www.tei-c.org/ns/1.0");

			// Collect the parameters needed for the TEI header
			addExtraParams(extraParams, traditionNode);
			writeTEIHeader(writer, extraParams);

			// Start chaining the text together
			writer.writeStartElement("text");
			ArrayList<Node> sectionList = new ArrayList<>();
			if (sectionId != null) {
				Node sectionNode = db.getNodeById(Long.parseLong(sectionId));
				sectionList.add(sectionNode);				
			} else {
				// get sections of traditions
				sectionList = VariantGraphService.getSectionNodes(tradId, db);
			}

			writer.writeStartElement("body");
			// Iterate through the list of section nodes and create the text section by section
			for (Node sectionNode : sectionList) {
				VariantListModel vlocs = new VariantListModel(sectionNode, baseWitness, excludeWitnesses, conflate,
						suppress, filterNonsense, filterTypeOne, significant, combine);

				List<ReadingModel> baseReadingChain = vlocs.getBaseReadings();

				// get section witnesses
				SectionModel sectionModel = new SectionModel(sectionNode);
				String sectionWitnesses =
						sectionModel.getWitnesses()
								.stream().map(w -> "#" + w)
								.collect(Collectors.joining(" "));

				// list witnesses in section
				writeWitnesses(writer, sectionWitnesses, "AppStart");
				writeText(writer, vlocs, baseReadingChain);

				// list end of witnesses in section
				writeWitnesses(writer, sectionWitnesses, "AppEnd");
			}

			writer.writeEndElement(); // end body

			writer.writeEndElement(); // end text
			writer.writeEndElement(); // end TEI
			// eventually...
			tx.success();
			writer.flush();
			out.close();
		} catch (IOException | XMLStreamException e) {
			String msg = "Error setting up XML output: " + e.getMessage();
			return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createXmlError(msg)).build();
		} catch (Exception e) {
			e.printStackTrace();
			String msg = "Error generating TEI output: " + e.getMessage();
			return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createXmlError(msg)).build();
		}

		return Response.ok(FileUtils.readFileToString(file, StandardCharsets.UTF_8), MediaType.APPLICATION_XML_TYPE)
				.build();
	}

	/**
	 * Method to write text with anchors and variants to XML document.
	 * @param writer The XML writer object to use.
	 * @param vlocs The {@link VariantListModel} holding all variants.
	 * @param baseReadingChain A list of {@link ReadingModel}s holding the base text.
	 * @throws XMLStreamException passed on from XMLStreamWriter
	 */
	private void writeText(XMLStreamWriter writer, VariantListModel vlocs, List<ReadingModel> baseReadingChain)
			throws XMLStreamException {
		long idCounter = 1;
		
		Iterator<VariantLocationModel> iterator = vlocs.getVariantlist().iterator();
		VariantLocationModel variant  = null;
		if (iterator.hasNext()) {
			variant = iterator.next();
		}
		ReadingModel prev = null;
		PeekingIterator<ReadingModel> chainIterator = new PeekingIterator<>(baseReadingChain.iterator());
		while (chainIterator.hasNext()) {
			ReadingModel baseReading = chainIterator.next();
			if (variant != null && variant.getVariants() != null && variant.getVariants().size() > 0) {
				boolean hasBeenWritten = false;
				// we need a while loop because there can be variants that add text
				// they will have no base and be in between readings (this loop should execute
				// 1 or 2 times.
				while (variant != null) {
					if (prev != null && variant.getBefore().getId().equals(prev.getId())) {
						writer.writeEmptyElement("anchor");
						// create an id for the next lemma
						String id = "ID" + idCounter++;
						writer.writeAttribute("id", id);
						// if there is a base reading, we print it
						boolean hasBase = variant.getBase() != null && variant.getBase().size()>0;
						if (hasBase) {
							writer.writeCharacters(getText(baseReading, chainIterator.peek()));
							hasBeenWritten = true;
						}
						writeReadings(writer, variant, id);
						if (iterator.hasNext()) {
							variant = iterator.next();		
						} else {
							variant = null;
						}
					} else {
						if (!hasBeenWritten) {
							writer.writeCharacters(getText(baseReading, chainIterator.peek()));
						}
						break;
					}
				}
			} else {
				writer.writeCharacters(getText(baseReading, chainIterator.peek()));
			}
			prev = baseReading;
			
		}
	}

	private void addExtraParams(Map<String, String> extraParams, Node traditionNode) {
		extraParams.put("title", traditionNode.getProperty("name").toString());
		if (traditionNode.hasRelationship(Direction.INCOMING, ERelations.OWNS_TRADITION)) {
			Node ownNode = traditionNode.getSingleRelationship(ERelations.OWNS_TRADITION, Direction.INCOMING)
					.getStartNode();
			extraParams.put("owner", (new UserModel(ownNode)).getId());
		}
		for (Relationship r : traditionNode.getRelationships(ERelations.HAS_WITNESS, Direction.OUTGOING)) {
			WitnessModel wm = new WitnessModel(r.getEndNode());
			extraParams.put("witness:" + wm.getId(), wm.getSigil());
		}
	}

	private void writeWitnesses(XMLStreamWriter writer, String sectionWitnesses, String id) throws XMLStreamException {
		writer.writeStartElement("app");
		writer.writeAttribute("id", id);
		writer.writeStartElement("rdg");
		writer.writeAttribute("wit", sectionWitnesses);
		writer.writeEmptyElement("witStart");
		writer.writeEndElement(); // end rdg
		writer.writeEndElement(); // end app
	}

	private String getText(ReadingModel reading, ReadingModel nextReading) {
		if (reading.getJoin_next()) {
			return reading.getText();
		} 
		if (nextReading!= null && nextReading.getJoin_prior()) {
			return reading.getText();
		}
		return reading.getText() + " ";
	}

	private void writeReadings(XMLStreamWriter writer, VariantLocationModel section, String id)
			throws XMLStreamException {
		writer.writeStartElement("app");
		writer.writeAttribute("from", id);
		for (VariantModel variant : section.getVariants()) {
			if (variant.getReadings() != null && variant.getReadings().size()> 0) {
				for (ReadingModel variantReading : variant.getReadings()) {
					writer.writeStartElement("rdg");
					StringBuilder sigils = new StringBuilder();
					for (String sigil : variantReading.getWitnesses()) {
						sigils.append("#").append(sigil).append(" ");
					}
					writer.writeAttribute("wit", sigils.toString().trim());
					writer.writeCharacters(variantReading.getText());
					writer.writeEndElement();
				}
			} else if (variant.getWitnesses().get("witnesses") != null && variant.getWitnesses().get("witnesses").size() > 0) {
				// if the witnesses omit text
				writer.writeStartElement("rdg");
				StringBuilder sigils = new StringBuilder();
				for (String sigil : variant.getWitnesses().get("witnesses")) {
					sigils.append("#").append(sigil).append(" ");
				}
				writer.writeAttribute("wit", sigils.toString().trim());
				writer.writeEndElement();
			}
		}
		writer.writeEndElement();

	}
}
